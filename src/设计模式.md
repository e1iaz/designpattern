# 适应设计模式
## Iterator模式
第一编写，觉得这个模式的思想是通过调用接口来实现迭代查询，而实现过程是可以随意修改，修改后不用在修改main函数的调用，解耦过程。

## Adapter模式
书用讲的是电压的转换来理解的，大概意思就是电脑需要低电压，不能直接使用，要一个适配器降压。对应的就是，我有一些现成的代码，在写别的代码的时候可以修改使用，但是修改的时候会造成bug，排查的时候要从头开始排查，但是加上一个转换器，将原先代码的基础上加上一层，并在这层上进行修改，就可以不用担心之前的代码了。  
提高复用，对拓展开放对修改关闭。

# 交给子类
## Template模式
模板模式，就是给定一个模板，然后在子类里实现，就像是小时候的画册，给定了框框，我们需要给它上色，怎么上色都是我们自己来决定的，和模板没有关系，而模板有规定了我不上色的范围。  
这个模式的优点就是父类编写了算法（框框）子类不用在编写，同时子类可以使用父类中定义的方法、增加方法实现新功能、重写父类的方法改变程序。  
父类和子类相互协作支撑整个程序，父类的方法过多，子类很轻松，但灵活性降低；父类的方法过少，子类很臃肿，而且容易重复代码。

## Factory Method模式
工厂模式，细分有三种，静态工厂模式、工厂模式、抽象工厂模式，其中静态工厂模式不在23种中。  
工厂模式的好处是不用关注创建对象的细节，比较方便。  
如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都用到。  

# 生成实例
## Singleton模式
单例模式，是提供一个实例，对实例的数量做了限制。  
单例模式有四个实现方式，懒汉模式、饿汉模式、静态内部类、枚举，懒汉模式是类加载的时候不初始化；饿汉模式在类加载的时候初始化；  
由于懒汉模式是之后创建实例，所以要考虑多线程的问题，不然会出现new多的情况。  
## Prototype模式
原型模式，中秋放假前夕，无心写了（逃

# 分开考虑
## Strategy模式
策略模式，就是将算法提出来，根据需求选择不同的算法而不用修改Strategy的接口。比如就是游戏难度。

# 一致性
## Decorator模式
装饰模式，书上写像是个蛋糕，可以向上面添加一层装饰，一层装饰后还能再添加一层装饰，因此装饰是和本体是一样的。这样的好处就是可以添加功能不用担心冲突。实现了解耦

# 管理状态
## Observer模式
观察者模式，我举得这个名字有个误导，因为是被观者者修改后，他对触发所有注册的观察者的update，而不是观察者主动观察到的。  
这个很容易就会想到Java网页，MVC模式。

# 避免浪费
## Proxy模式
代理模式，根据书中的意思是将当时不需要的、耗时的，放到用的时候再处理。有些像TiDB中的锁。不过还不是很理解这个模式