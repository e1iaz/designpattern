# 适应设计模式
## Iterator模式
第一编写，觉得这个模式的思想是通过调用接口来实现迭代查询，而实现过程是可以随意修改，修改后不用在修改main函数的调用，解耦过程。

## Adapter模式
书用讲的是电压的转换来理解的，大概意思就是电脑需要低电压，不能直接使用，要一个适配器降压。对应的就是，我有一些现成的代码，在写别的代码的时候可以修改使用，但是修改的时候会造成bug，排查的时候要从头开始排查，但是加上一个转换器，将原先代码的基础上加上一层，并在这层上进行修改，就可以不用担心之前的代码了。  
提高复用，对拓展开放对修改关闭。

# 交给子类
## Template模式
模板模式，就是给定一个模板，然后在子类里实现，就像是小时候的画册，给定了框框，我们需要给它上色，怎么上色都是我们自己来决定的，和模板没有关系，而模板有规定了我不上色的范围。  
这个模式的优点就是父类编写了算法（框框）子类不用在编写，同时子类可以使用父类中定义的方法、增加方法实现新功能、重写父类的方法改变程序。  
父类和子类相互协作支撑整个程序，父类的方法过多，子类很轻松，但灵活性降低；父类的方法过少，子类很臃肿，而且容易重复代码。

## Factory Method模式
工厂模式，理解的还不是很好。工厂是使用模板生产产品的，所以创建一个产品框架和一个工厂框架，在子类里确定是什么产品和什么产品。当需要时，向工厂申请产品。  
我觉得这个样例虽然简单，但理解工厂模式有些困难。等以后遇到好的理解例子在写一下。  

# 生成实例
## Singletion模式
单例模式，是提供一个实例，对实例的数量做了限制。书上说实例之间会造成影响，项目经历少，不是很清楚。  

# 分开考虑
## Strategy模式
策略模式，就是将算法提出来，根据需求选择不同的算法而不用修改Strategy的接口。比如就是游戏难度。

# 一致性
## Decorator模式
装饰模式，书上写像是个蛋糕，可以向上面添加一层装饰，一层装饰后还能再添加一层装饰，因此装饰是和本体是一样的。这样的好处就是可以添加功能不用担心冲突。实现了解耦

# 管理状态
## Observer模式
观察者模式，我举得这个名字有个误导，因为是被观者者修改后，他对触发所有注册的观察者的update，而不是观察者主动观察到的。  
这个很容易就会想到Java网页，MVC模式。

# 避免浪费
## Proxy模式
代理模式，根据书中的意思是将当时不需要的、耗时的，放到用的时候再处理。有些像TiDB中的锁。不过还不是很理解这个模式